# Cache说明

## 概述
为主存添加了一级直接相连的Cache，主存与Cache之间的数据传输是以块为单位的。主要参数和策略如下：

* 块大小为8，相联度为4，Cache总容量为4096个字节。
* Cache采用了随机替换的替换策略
* 写Cache时采用写回，写不命中时采用写分配。
* 加入了写缓冲机制，并不直接写回主存，而是写入写缓冲，由写缓冲择机写入主存。

Cache的具体实现在Resources.py中，通过修改访存接口，已经将Cache集成到了指令流水线中。

## 测试
通过一个矩阵乘法的地址访问序列对Cache进行了测试。分别使用两个版本进行测试，一个是经典方法直接相乘，另一种是矩阵分块乘法。测试的相关说明如下：

* 并未直接使用汇编代码在流水线中测试，因为访存规模过大，运行过慢，通过模拟循环过程生成了访存序列，再通过Cache读写接口进行测试
* 矩阵规模为64*64，每个元素占8字节。读写Cache时以8字节为单位，每次访存都会写入或者读取8字节。
* 由于Cache块大小为8，每次访存读取8字节，每次访存可能会读取两个块，若两个块都缺失，认为其可以从主存中取出两个块，只计算一次访存Miss

不分块的地址序列伪代码如下：
```
for i in range(N):
    for j in range(N):
        for k in range(N):
            # 读y和z
            r += y[i][k] * z[k][j]
    # 写x
    x[i][j] = r
```
测试结果如下：

![不分块时Cache测试结果](Test/不分块结果.png)

分块的地址序列伪代码如下：
```
for jj in range(0, N, B):
    for kk in range(0, N, B):
        for i in range(N):
            for j in range(min(jj+B-1, N)):
                r=0
                for k in range(kk, min(kk+B-1, N)):
                    # 读y读z
                    r += y[i][k] * z[k][j]
                # 先读x，再写x
                x[i][j] = x[i][j] + r
```
测试结果如下：

![分块时Cache测试结果](Test/分块结果.png)
