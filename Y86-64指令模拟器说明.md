# Y86-64流水线CPU模拟器
  
## 概述
* 采用拓展的Y86指令集，为原来的Y86指令集添加了乘法和除法两条指令，它们的EX阶段分别需要5和10个周期。

* 采用经典的取指，译码，执行，访存，写回五阶段流水线。模拟执行流水线时，利用threading模块多线程的函数来实现流水线每个周期每个阶段的并行。

## Test
  * Test文件夹中存放机器码编写的coe文件，在主程序中加载不同的coe文件以进行不同的测试。

  * add_100.coe文件实现1到100的加法测试
  
  *  test_开头的测试文件分别对流水线的不同功能和有结构依赖或者数据依赖的指令进行测试

## 特殊指令（结构依赖）的解决
* 我们完成了两个版本，在第一个版本中，我们假设每条指令的EX段都只需要2个周期，通过增加资源，用两个独立的EX阶段交替执行实现每周期

* 乘法指令MULTQ的EX段有5拍，而除法指令DIVQ的EX段有10拍，在处理这两条指令时，流水线阻塞直到EX阶段可用才进行下一条指令的EX阶段的计算。

## 数据冲突的解决
* 通过阻塞解决数据冲突，直到EX段或者MEM段的结果写入寄存器，才执行下一条与前面存在数据冲突指令的EX段。


## 控制冲突的解决
1. ret指令依赖
   
   ret指令在MEM段计算出valM，下一条指令需要在其MEM段计算完毕之后才能取出正确的地址。我们在取出ret指令后阻塞流水线，令接下来取出的指令为nop，直到ret指令的MEM段执行完毕。

2. jxx指令依赖

 * 在我们的实现中，jxx指令是否跳转依赖于条件码，而并不直接编码于指令中，所以我们不能通过提前计算来提前预测跳转结果。故只有在jxx指令上一条整数计算指令的EX段设置条件码（CC）完成之后，才能决定跳转结果。
  
 * jxx指令在其EX段产生跳转码Cnd，故下一条指令在其EX段执行结束后才能正确取地址。我们在取出jxx指令后阻塞流水线，令取出的新指令为nop，直到jxx指令的EX段计算出正确的Cnd值。